#!/usr/bin/env python3

import json
import os
import sys
import geopandas as g
import pandas as pd
import geopandas as gpd
from roveranalyzer.utils import Project
from shapely.geometry import Point
import numpy as np
import random
import random
import argparse
import xml.etree.ElementTree as ET


def parse_args():
    p = argparse.ArgumentParser(description="Create random positions based on Vadere or Sumo bounds for stationary nodes")
    p.add_argument("--vadere", help="Vadere scenario file to extract bounds", default="", type=str)
    p.add_argument("--sumo", help="Sumo network file to extract bounds", default="", type=str)
    p.add_argument("-n", "--number-of-positions", help="number of nodes to create", default=100, type=int)
    p.add_argument("-N", "--number-of-runs", help="Number of runs to crated", default=1, type=int)
    p.add_argument("-o", "--output", help="output file", required=True)
    p.add_argument("--seed", help="set seed for random generator. If -1 use random seed", default=None, type=int)
    p.add_argument("--config-name", help="Name used for generated configs", default="misc_pos", type=str)

    return p.parse_args()

class OppIniWriter:

    @classmethod
    def from_sumo(cls, path, seed=None):
        try:
            tree = ET.parse(path)
            loc = tree.find("location")
            offset = loc.attrib["netOffset"].split(",")
            if len(offset) != 2:
                raise ValueError(f"Expected 2 items in offest got {offset}")
            # need positive offset
            offset = np.abs(np.array([float(i.strip()) for i in offset]))

            bound = loc.attrib["convBoundary"].split(",")
            if len(bound) != 4:
                raise ValueError(f"Expected 4 items in bound got {bound}")
            bound = np.array([float(i.strip()) for i in bound])
            bound = np.array([bound[2]-bound[0], bound[3]-bound[1]])

            proj = Project.from_proj(loc.attrib["projParameter"])

            if seed is None:
                seed = random.randint(-2147483648, 2147483647)
            return cls(proj, offset, bound, seed)

        except Exception as e:
            raise RuntimeError(f"cannot parse sumo netfile {e}")

    @classmethod
    def from_vadere(cls, path, seed=None):
        with open(path, "r", encoding="utf-8") as fd:
            s = json.load(fd)
        try:
            bound = s["scenario"]["topography"]["attributes"]["bounds"]
            bound = np.array([bound["width"], bound["height"]])
            ref = s["scenario"]["topography"]["attributes"]["referenceCoordinateSystem"]
            offset = np.array([float(ref["translation"]["x"]), float(ref["translation"]["y"])])
            if seed is None:
                seed = random.randint(-2147483648, 2147483647)
            return cls(Project.from_proj(ref["epsgCode"]), offset, bound, seed)
        except Exception as e:
            raise RuntimeError(f"cannot parse scenario file {e}")


    def __init__(self, source_crs, offset, bound, seed=42) -> None:
        self.nodes = {}
        self._node_count = 0
        self.crs = Project.WSG84_lat_lon
        self.to_lat_lon : Project = Project(source_crs=source_crs, dest_crs=Project.WSG84_lat_lon)
        self.offset = offset
        self.bound = bound
        self.seed = seed
    


    def add_point(self, x: float, y:float, run):
        _p = np.array([x, y])
        if all(_p >= 0) and all(_p <= self.bound):
            _d = Point(self.offset + _p)
            if run not in self.nodes:
                self.nodes[run] = []
            self.nodes[run].append([self._node_count, _d.x, _d.y])
            self._node_count += 1
        else:
            raise ValueError("Out of bound")

    def to_geo_frame(self, epsg=Project.OpenStreetMaps, run=0):
        
        nodes = self.nodes[run]
        geo = [Point(x, y) for _, x, y in nodes]
        df = pd.DataFrame(nodes, columns=["id","x", "y"])
        df = gpd.GeoDataFrame(df, geometry=geo, crs=Project.UTM_32N)
        df = df.to_crs(epsg=epsg.replace("EPSG:", "")) # Google
        return df
    
    def write_config(self, writer, config="", run=0):
        _df = self.to_geo_frame(Project.WSG84_lat_lon, run=run)

        nodes = self.nodes[run]

        writer.write(config)
        writer.write("\n")
        writer.write(f"*.numMisc = {len(nodes)}\n")
        for id, row in _df.iterrows():
            writer.write(f"*.misc[{id}].mobility.initialLatitude = {row.geometry.y}deg\n")
            writer.write(f"*.misc[{id}].mobility.initialLongitude = {row.geometry.x}deg\n")
        writer.write("\n")
    
    def write_all_configs(self, writer, config_template):
        writer.write(f"# Generated with python3 random.Random(seed={self.seed})")
        writer.write("\n\n")
        for run in self.nodes.keys():
            self.write_config(writer, f"[Config {config_template}_{run}]", run=run)
            writer.write("\n")


    def uniform(self, num_nodes, num_runs=1):
        rnd = random.Random(self.seed)
        self._node_count = 0
        for run in range(num_runs):
            for _ in range(num_nodes):
                self.add_point(rnd.uniform(0.0, self.bound[0]), rnd.uniform(0.0, self.bound[1]), run)
            self._node_count = 0

def override_yes_no_append():
    print("do you want to override (yes) the file or append (a) to it? (n) or for exit ")
    print("[yes/n/a] [ENTER]")
    choice = input().lower()
    if choice == "yes":
        return "w"
    elif choice in ["a", "append"]:
        return "a"
    else:
        return None



ns = parse_args()
if ns.vadere != "":
    w : OppIniWriter = OppIniWriter.from_vadere(ns.vadere, seed=ns.seed)
elif ns.sumo != "":
    w : OppIniWriter = OppIniWriter.from_sumo(ns.sumo, seed=ns.seed)

mode = "w"
if os.path.exists(ns.output):
    print("Output file already exist!")
    mode = override_yes_no_append()
    if mode is None:
        print("Abort. Do nothing.")
        sys.exit(0)

w.uniform(ns.number_of_positions, ns.number_of_runs)

with open(ns.output, mode=mode, encoding="utf-8") as out:
    if mode == "w":
        print(f"write to {os.path.abspath(ns.output)}")
    elif mode == "a":
        print(f"append to {os.path.abspath(ns.output)}")
        
    w.write_all_configs(out, ns.config_name)


