[Config Defaults]

output-scalar-file-append = false
print-undisposed = true

#============= Simulation parameters ================
sim-time-limit=300s
warmup-period=60s      # Note: When analyzing the results, you need to apply the same warmup-period to measurement data!
repeat = 3
seed-set = ${repetition}

#============= Mobility parameters ==================
**.mobility.constraintAreaMinZ = 0m
**.mobility.constraintAreaMaxZ = 0m

#============= AMC module parameters ================
# (number of RBs is not included here because it is scenario specific)
**.ueTxPower = 20dBm
**.eNodeBTxPower = 20dBm

#============= Channel control parameters ===========
**.channelControl.pMax = 1W
**.channelControl.alpha = 1.0
**.channelControl.carrierFrequency = 2600e+6Hz

#============= Channel model parameters =============
# for a complete list of all parameters:
#   refer to LteChannelModels.ned
**.channelModel[0].shadowing = false   # enable/disable shadowing
**.channelModel[0].scenario = "INDOOR_HOTSPOT"  # pathloss scenario from ITU: INDOOR_HOTSPOT, URBAN_MICROCELL, URBAN_MACROCELL, RURAL_MACROCELL, SUBURBAN_MACROCELL
**.channelModel[0].nodeb_height = 1.5m
**.channelModel[0].ue_height = 1.5m
**.channelModel[0].building_height = 20m

**.channelModel[0].street_wide = 20m
**.channelModel[0].antennaGainUe = 0dBi
**.channelModel[0].antennGainEnB = 0dBi

**.channelModel[0].dynamic_los = false   # If true enable the possibility to switch dinamically the LOS/NLOS pathloss computation
**.channelModel[0].fixed_los = true      # If dynamic-los is false this parameter, if true, compute LOS pathloss otherwise compute NLOS pathloss
**.channelModel[0].fading = false        # Enable/disable fading
**.channelModel[0].fading_type = "JAKES" # Fading type (JAKES or RAYGHLEY) if fading is enabled
**.channelModel[0].fading_paths = 6      # If jakes fading this parameter specify the number of path (tap channel)
**.channelModel[0].delay_rms = 363e-9s

**.channelModel[0].extCell_interference = false # if true, enables the inter-cell interference computation for DL connections from external cells
**.channelModel[0].downlink_interference = true # if true, enables the inter-cell interference computation for DL connections
**.channelModel[0].uplink_interference = true   # if true, enables the interference computation for UL connections
**.channelModel[0].d2d_interference = true      # if true, enables the interference computation for D2D connections

#============= Protocol stack parameters  ===========
#(as in OpenAirInterface Configuration)
**.rlc.um.queueSize = 5000000B              # OpenAirInterface queue limit for RLC_MODE_UM  (Commit f58ad3c39f04ca7305202749a7dad2b25ef6b942 file rlc.c  method rlc_data_req() line 478)
**.mac.queueSize = 10000B					# reduce MAC queue size - OpenAirInterface does not queue packets in mac layer
**.pdcpRrc.backgroundRlc = "UM"             # default RLC type (0: TM, 1: UM, 2: AM)

**.configurator.config = xmldoc("./demo.xml") # configuration of IPv4 addresses used in the network

#============= Statistics ===========================
output-scalar-file = ${resultdir}/${configname}/${repetition}.sca
output-vector-file = ${resultdir}/${configname}/${repetition}.vec
seed-set = ${repetition}

**.routingRecorder.enabled = false

#============= Positioning and mobility ============
*.eNB[*].mobility.initFromDisplayString = true
# *.eNB[*].mobility.initialX = 0.5m
# *.eNB[*].mobility.initialY = 1m
# set constrains for area according to size of
# shielded lab R1.009a
*.ue[*].mobility.typename = "LinearMobility"
*.ue[*].mobility.constraintAreaMaxX = 7.5m
*.ue[*].mobility.constraintAreaMaxY = 10m
*.ue[*].mobility.constraintAreaMinX = 0m
*.ue[*].mobility.constraintAreaMinY = 0m
*.ue[*].mobility.initFromDisplayString = false
*.ue[0].mobility.initialX = 5m
*.ue[0].mobility.initialY = 2.5m
*.ue[1..].mobility.initialX = 5m
*.ue[1..].mobility.initialY = 2.5m + ancestorIndex(1)*3.0m
*.ue[*].mobility.speed = 0mps
#------------------------------------#

# record relevant statistics
**.alert*.vector-recording = true
# all other vectors are disabled
**.vector-recording = false